# Structured workflows

Structured workflows let you decorate functions and classes to define workflows
that:

- are [durable][durable] - if the workflow fails partway through, we can resume
  without repeating past steps and duplicating LLM inference requests, saving you
  money
- give agents memory about the steps the tasks steps in a workflow,
- record all LLM and agent interactions for observability
- load docs for RAG or search relevant to the workflow
- add human-in-the-loop, or pause-and-resume points so you can pause a workflow
  while waiting for external input

If you are familiar with [Temporal](https://temporal.io/), structured workflows
look similarly, but each workflow is given extra LLM-specific features.  The
name is inspired by [structured programming][structured-programming].


## Some example use cases

Structured workflows are great for have business or analysis workflows that are
not directly user-facing. Some examples:

- You just fine-tuned a new model and want to compare its outputs to your
  current model. We help you run all inferences simultaneously, and if any fail,
  re-run just the failed requests.
- You have a set of financial documents and want to extract information from
  them to generate a report.
- You want an LLM to post-process human or AI calls and text chats to come up
  with follow-up items.


If you are building something closer to a chatbot, check out the
[Request/Reply Workflows][req-rep-wf] docs.

## In-depth use case: comparing multiple LLM models

TODO


[durable]: /workflows-and-durability
[structured-programming]: https://en.wikipedia.org/wiki/Structured_programming
[req-rep-wf]: /workflows-and-durability/request-reply-workflows
